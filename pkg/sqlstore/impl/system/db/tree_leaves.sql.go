// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: tree_leaves.sql

package db

import (
	"context"
)

const deleteProcessing = `-- name: DeleteProcessing :exec
DELETE FROM system_tree_leaves WHERE chain_id = ?1 AND block_number = ?2 AND processing = 1
`

type DeleteProcessingParams struct {
	ChainID     int64
	BlockNumber int64
}

func (q *Queries) DeleteProcessing(ctx context.Context, arg DeleteProcessingParams) error {
	_, err := q.exec(ctx, q.deleteProcessingStmt, deleteProcessing, arg.ChainID, arg.BlockNumber)
	return err
}

const fetchChainIDAndBlockNumber = `-- name: FetchChainIDAndBlockNumber :many
SELECT chain_id, block_number FROM system_tree_leaves GROUP BY chain_id, block_number ORDER BY chain_id, block_number
`

type FetchChainIDAndBlockNumberRow struct {
	ChainID     int64
	BlockNumber int64
}

func (q *Queries) FetchChainIDAndBlockNumber(ctx context.Context) ([]FetchChainIDAndBlockNumberRow, error) {
	rows, err := q.query(ctx, q.fetchChainIDAndBlockNumberStmt, fetchChainIDAndBlockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChainIDAndBlockNumberRow
	for rows.Next() {
		var i FetchChainIDAndBlockNumberRow
		if err := rows.Scan(&i.ChainID, &i.BlockNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLeavesByChainIDAndBlockNumber = `-- name: FetchLeavesByChainIDAndBlockNumber :many
UPDATE system_tree_leaves SET processing = 1 WHERE chain_id = ?1 AND block_number = ?2 RETURNING prefix, chain_id, table_id, block_number, leaves, processing
`

type FetchLeavesByChainIDAndBlockNumberParams struct {
	ChainID     int64
	BlockNumber int64
}

func (q *Queries) FetchLeavesByChainIDAndBlockNumber(ctx context.Context, arg FetchLeavesByChainIDAndBlockNumberParams) ([]SystemTreeLeafe, error) {
	rows, err := q.query(ctx, q.fetchLeavesByChainIDAndBlockNumberStmt, fetchLeavesByChainIDAndBlockNumber, arg.ChainID, arg.BlockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SystemTreeLeafe
	for rows.Next() {
		var i SystemTreeLeafe
		if err := rows.Scan(
			&i.Prefix,
			&i.ChainID,
			&i.TableID,
			&i.BlockNumber,
			&i.Leaves,
			&i.Processing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
